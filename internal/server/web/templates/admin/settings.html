{{ define "content" }}
<div class="settings-container">
    <div class="panel">
        <form id="settingsForm">
            <input type="hidden" name="csrf_token" value="{{ .CSRFToken }}">
            <div class="setting-group">
                <label for="siteTitle">SITE TITLE</label>
                <input type="text" id="siteTitle" name="siteTitle" value="{{ index .Data.Settings "site_title" }}" required>
            </div>
            <div class="setting-group">
                <label for="siteURL">SITE URL</label>
                <input type="url" id="siteURL" name="siteURL" value="{{ index .Data.Settings "site_url" }}" required>
                <div class="help-text">
                    The base URL of your site (e.g., https://example.com). Used for RSS feed validation and absolute links.
                </div>
            </div>
            <div class="setting-group">
                <label for="maxPosts">MAXIMUM POSTS</label>
                <input type="number" id="maxPosts" name="maxPosts" value="{{ index .Data.Settings "max_posts" }}" min="1" required>
            </div>
            <div class="setting-group">
                <label for="updateInterval">UPDATE INTERVAL (SECONDS)</label>
                <input type="number" id="updateInterval" name="updateInterval" value="{{ index .Data.Settings "update_interval" }}" min="60" required>
            </div>
            <div class="setting-group">
                <label for="headerLinkText">HEADER LINK TEXT</label>
                <input type="text" id="headerLinkText" name="headerLinkText" value="{{ index .Data.Settings "header_link_text" }}">
                <div class="help-text">
                    Optional. Text for the header link (appears at the top of the page).
                </div>
            </div>            <div class="setting-group">
                <label for="headerLinkURL">HEADER LINK URL</label>
                <input type="url" id="headerLinkURL" name="headerLinkURL" value="{{ index .Data.Settings "header_link_url" }}">
                <div class="help-text">
                    Optional. URL for the header link (e.g., / for home page).
                </div>
            </div>
            <div class="setting-group">
                <label>FAVICON</label>
                {{ if index .Data.Settings "favicon_url" }}
                <div class="current-image">
                    <img src="/static/images/{{ index .Data.Settings "favicon_url" }}" alt="Favicon" class="img-32">
                </div>
                {{ end }}
                <div class="upload-container">
                    <div class="file-input-wrapper">
                        <input type="file" id="favicon" name="favicon" accept="image/x-icon,image/png,image/ico" class="file-input">
                    </div>
                    <div id="faviconStatus" class="image-upload-status"></div>
                    <div id="faviconPreview" class="upload-preview hidden">
                        <img src="" alt="Upload preview" class="img-32">
                    </div>
                </div>
                <div class="help-text">
                    Upload an ICO or PNG file (max 1MB)
                </div>
            </div>
            <div class="setting-group">
                <label for="metaDescription">META DESCRIPTION</label>
                <textarea id="metaDescription" name="metaDescription" rows="3" placeholder="Brief site description for social media cards">{{ index .Data.Settings "meta_description" }}</textarea>
                <div class="help-text">
                    A short description that appears when links are shared on social media.
                </div>
            </div>
            <div class="setting-group">
                <label for="metaImage">SOCIAL CARD IMAGE</label>
                <div class="upload-container">
                    {{ if index .Data.Settings "meta_image_url" }}
                    <div class="current-image">
                        <img src="/static/images/{{ index .Data.Settings "meta_image_url" }}" alt="Social card image" class="img-100">
                    </div>
                    {{ end }}
                    <div class="file-input-wrapper">
                        <input type="file" id="metaImage" name="image" accept="image/*" class="file-input">
                    </div>
                    <div id="metaImageStatus" class="image-upload-status"></div>
                    <div id="metaImagePreview" class="upload-preview hidden">
                        <img src="" alt="Upload preview" class="img-100">
                    </div>
                </div>
                <div class="help-text">
                    Image shown when links are shared (recommended: 1200x630px)
                </div>
            </div>
            <div class="setting-group">
                <label for="footerLinkText">FOOTER LINK TEXT</label>
                <input type="text" id="footerLinkText" name="footerLinkText" value="{{ index .Data.Settings "footer_link_text" }}">
                <div class="help-text">
                    Optional. Text for the footer link (appears at the bottom of the page).
                </div>
            </div>
            <div class="setting-group">
                <label for="footerLinkURL">FOOTER LINK URL</label>
                <input type="url" id="footerLinkURL" name="footerLinkURL" value="{{ index .Data.Settings "footer_link_url" }}">
                <div class="help-text">
                    Optional. URL for the footer link (e.g., / for home page).
                </div>
            </div>
            <div class="setting-group">
                <label for="footerImageHeight">FOOTER IMAGE HEIGHT</label>
                <input type="text" id="footerImageHeight" name="footerImageHeight" value="{{ index .Data.Settings "footer_image_height" }}" placeholder="50px">
                <div class="help-text">
                    Optional. CSS height value for footer image (e.g., 50px, 3rem). Only used when footer image is uploaded.
                </div>
            </div>
            <div class="setting-group">
                <label>FOOTER IMAGE</label>
                {{ if index .Data.Settings "footer_image_url" }}
                <div class="current-image">
                    <img src="/static/images/{{ index .Data.Settings "footer_image_url" }}" alt="Footer image" class="img-100">
                </div>
                {{ end }}
                <div class="upload-container">
                    <div class="file-input-wrapper">
                        <input type="file" id="footerImage" name="footerImage" accept="image/*" class="file-input">
                    </div>
                    <div id="footerImageStatus" class="image-upload-status"></div>
                    <div id="footerImagePreview" class="upload-preview hidden">
                        <img src="" alt="Upload preview" class="img-100">
                    </div>
                </div>
            </div>
            <div class="setting-group">
                <label for="trackingCode">TRACKING CODE</label>
                <textarea id="trackingCode" name="trackingCode" rows="5" placeholder="Paste your analytics or tracking code here">{{ index .Data.Settings "tracking_code" }}</textarea>
                <div class="help-text">
                    Paste your analytics code (e.g., Google Analytics, Umami) here. It will be added to the bottom of every page.
                </div>
            </div>
            <div class="setting-group">
                <label for="publicTheme">PUBLIC THEME</label>
                <select id="publicTheme" name="publicTheme">
                    {{ $publicTheme := getSetting .Data.Settings "public_theme" (getSetting .Data.Settings "theme" "terminal") }}
                    {{ range getAvailableThemes }}
                    <option value="{{ . }}" {{ if eq $publicTheme . }}selected{{ end }}>{{ title . }}</option>
                    {{ end }}
                </select>
                <div class="help-text">Choose the visual theme for the public index.</div>
            </div>
            <div class="setting-group">
                <label for="adminTheme">ADMIN THEME</label>
                <select id="adminTheme" name="adminTheme">
                    {{ $adminTheme := getSetting .Data.Settings "admin_theme" (getSetting .Data.Settings "theme" "terminal") }}
                    {{ range getAvailableThemes }}
                    <option value="{{ . }}" {{ if eq $adminTheme . }}selected{{ end }}>{{ title . }}</option>
                    {{ end }}
                </select>
                <div class="help-text">Choose the visual theme for the admin backend.</div>
            </div>
            
            <!-- Theme Management -->
            <div class="setting-group">
                <label>THEME MANAGEMENT</label>
                <div class="help-text">
                    Scan for new themes in the themes directory without restarting the server.
                </div>
                <button type="button" id="scanThemesButton" class="action-btn secondary">
                    SCAN FOR NEW THEMES
                </button>
                <div id="themesScanStatus" class="status"></div>
            </div>
            
            <!-- Template Updates -->
            <div class="setting-group">
                <label>TEMPLATE UPDATES</label>
                <div class="help-text">
                    Force update all templates and themes from embedded files. This overwrites any local customizations.
                </div>
                <button type="button" id="updateTemplatesButton" class="action-btn secondary">
                    UPDATE TEMPLATES
                </button>
                <div id="templatesUpdateStatus" class="status"></div>
            </div>
            
            <!-- Public Theme Selection -->
            <div class="setting-group">
                <label>AVAILABLE THEMES FOR USERS</label>
                <div class="help-text">
                    Select which themes users can choose from on the public pages. Only visible when "Allow Public Theme Selection" is enabled.
                </div>
                <div class="checkbox-group" id="availableThemesGroup">
                    {{ $availableThemes := getAvailableThemes }}
                    {{ range $theme := $availableThemes }}
                    <label class="checkbox-label">
                        <input type="checkbox" name="public_available_themes" value="{{ $theme }}" checked>
                        {{ title $theme }}
                    </label>
                    {{ end }}
                </div>
            </div>
            <div class="setting-group">
                <label for="timezone">TIMEZONE</label>
                <select id="timezone" name="timezone" class="timezone-select">
                    {{ $currentTZ := index .Data.Settings "timezone" }}
                    <option value="UTC" {{ if eq $currentTZ "UTC" }}selected{{ end }}>UTC</option>
                    <optgroup label="Africa">
                        <option value="Africa/Abidjan" {{ if eq $currentTZ "Africa/Abidjan" }}selected{{ end }}>Abidjan</option>
                        <option value="Africa/Accra" {{ if eq $currentTZ "Africa/Accra" }}selected{{ end }}>Accra</option>
                        <option value="Africa/Addis_Ababa" {{ if eq $currentTZ "Africa/Addis_Ababa" }}selected{{ end }}>Addis Ababa</option>
                        <option value="Africa/Algiers" {{ if eq $currentTZ "Africa/Algiers" }}selected{{ end }}>Algiers</option>
                        <option value="Africa/Cairo" {{ if eq $currentTZ "Africa/Cairo" }}selected{{ end }}>Cairo</option>
                        <option value="Africa/Casablanca" {{ if eq $currentTZ "Africa/Casablanca" }}selected{{ end }}>Casablanca</option>
                        <option value="Africa/Johannesburg" {{ if eq $currentTZ "Africa/Johannesburg" }}selected{{ end }}>Johannesburg</option>
                        <option value="Africa/Lagos" {{ if eq $currentTZ "Africa/Lagos" }}selected{{ end }}>Lagos</option>
                        <!-- Additional African time zones -->
                    </optgroup>
                    <optgroup label="America">
                        <option value="America/Adak" {{ if eq $currentTZ "America/Adak" }}selected{{ end }}>Adak</option>
                        <option value="America/Anchorage" {{ if eq $currentTZ "America/Anchorage" }}selected{{ end }}>Anchorage</option>
                        <option value="America/Chicago" {{ if eq $currentTZ "America/Chicago" }}selected{{ end }}>Chicago</option>
                        <option value="America/Denver" {{ if eq $currentTZ "America/Denver" }}selected{{ end }}>Denver</option>
                        <option value="America/Honolulu" {{ if eq $currentTZ "America/Honolulu" }}selected{{ end }}>Honolulu</option>
                        <option value="America/Los_Angeles" {{ if eq $currentTZ "America/Los_Angeles" }}selected{{ end }}>Los Angeles</option>
                        <option value="America/New_York" {{ if eq $currentTZ "America/New_York" }}selected{{ end }}>New York</option>
                        <option value="America/Phoenix" {{ if eq $currentTZ "America/Phoenix" }}selected{{ end }}>Phoenix</option>
                        <option value="America/Sao_Paulo" {{ if eq $currentTZ "America/Sao_Paulo" }}selected{{ end }}>SÃ£o Paulo</option>
                        <!-- Additional American time zones -->
                    </optgroup>
                    <optgroup label="Asia">
                        <option value="Asia/Bangkok" {{ if eq $currentTZ "Asia/Bangkok" }}selected{{ end }}>Bangkok</option>
                        <option value="Asia/Dubai" {{ if eq $currentTZ "Asia/Dubai" }}selected{{ end }}>Dubai</option>
                        <option value="Asia/Hong_Kong" {{ if eq $currentTZ "Asia/Hong_Kong" }}selected{{ end }}>Hong Kong</option>
                        <option value="Asia/Kolkata" {{ if eq $currentTZ "Asia/Kolkata" }}selected{{ end }}>Kolkata</option>
                        <option value="Asia/Seoul" {{ if eq $currentTZ "Asia/Seoul" }}selected{{ end }}>Seoul</option>
                        <option value="Asia/Shanghai" {{ if eq $currentTZ "Asia/Shanghai" }}selected{{ end }}>Shanghai</option>
                        <option value="Asia/Singapore" {{ if eq $currentTZ "Asia/Singapore" }}selected{{ end }}>Singapore</option>
                        <option value="Asia/Tokyo" {{ if eq $currentTZ "Asia/Tokyo" }}selected{{ end }}>Tokyo</option>
                        <!-- Additional Asian time zones -->
                    </optgroup>
                    <optgroup label="Europe">
                        <option value="Europe/Amsterdam" {{ if eq $currentTZ "Europe/Amsterdam" }}selected{{ end }}>Amsterdam</option>
                        <option value="Europe/Berlin" {{ if eq $currentTZ "Europe/Berlin" }}selected{{ end }}>Berlin</option>
                        <option value="Europe/Istanbul" {{ if eq $currentTZ "Europe/Istanbul" }}selected{{ end }}>Istanbul</option>
                        <option value="Europe/London" {{ if eq $currentTZ "Europe/London" }}selected{{ end }}>London</option>
                        <option value="Europe/Moscow" {{ if eq $currentTZ "Europe/Moscow" }}selected{{ end }}>Moscow</option>
                        <option value="Europe/Paris" {{ if eq $currentTZ "Europe/Paris" }}selected{{ end }}>Paris</option>
                        <!-- Additional European time zones -->
                    </optgroup>
                    <optgroup label="Oceania">
                        <option value="Australia/Adelaide" {{ if eq $currentTZ "Australia/Adelaide" }}selected{{ end }}>Adelaide</option>
                        <option value="Australia/Brisbane" {{ if eq $currentTZ "Australia/Brisbane" }}selected{{ end }}>Brisbane</option>
                        <option value="Australia/Darwin" {{ if eq $currentTZ "Australia/Darwin" }}selected{{ end }}>Darwin</option>
                        <option value="Australia/Melbourne" {{ if eq $currentTZ "Australia/Melbourne" }}selected{{ end }}>Melbourne</option>
                        <option value="Australia/Perth" {{ if eq $currentTZ "Australia/Perth" }}selected{{ end }}>Perth</option>
                        <option value="Australia/Sydney" {{ if eq $currentTZ "Australia/Sydney" }}selected{{ end }}>Sydney</option>
                        <option value="Pacific/Auckland" {{ if eq $currentTZ "Pacific/Auckland" }}selected{{ end }}>Auckland</option>
                        <!-- Additional Oceania time zones -->
                    </optgroup>
                </select>
            </div>
            
            <!-- Entry Display Settings -->
            <div class="setting-group">
                <label>ENTRY DISPLAY SETTINGS</label>
                <div class="help-text">
                    Configure how entries are displayed on the main page.
                </div>
                
                <div class="form-row">
                    <div class="checkbox-group">
                        <label class="checkbox-label" for="showBlogName">
                            <input type="checkbox" id="showBlogName" name="show_blog_name" 
                                   {{ if eq (index .Data.Settings "show_blog_name") "true" }}checked{{ end }}>
                            Show Blog Name
                        </label>
                        <div class="help-text">
                            Display the feed/blog name as a prefix to entry titles (e.g., "Blog Name: Article Title").
                        </div>
                    </div>
                    
                    <div class="checkbox-group">
                        <label class="checkbox-label" for="showBodyText">
                            <input type="checkbox" id="showBodyText" name="show_body_text" 
                                   {{ if eq (index .Data.Settings "show_body_text") "true" }}checked{{ end }}>
                            Show Entry Preview
                        </label>
                        <div class="help-text">
                            Display a preview of the entry content below the title.
                        </div>
                    </div>
                    
                    <div class="checkbox-group">
                        <label class="checkbox-label" for="allowPublicThemeSelection">
                            <input type="checkbox" id="allowPublicThemeSelection" name="allow_public_theme_selection" 
                                   {{ if eq (index .Data.Settings "allow_public_theme_selection") "true" }}checked{{ end }}>
                            Allow Public Theme Selection
                        </label>
                        <div class="help-text">
                            Let visitors choose their preferred theme via a settings menu on the public pages.
                        </div>
                    </div>
                </div>
                
                <div class="setting-group">
                    <label for="bodyTextLength">PREVIEW LENGTH (CHARACTERS)</label>
                    <input type="number" id="bodyTextLength" name="body_text_length" 
                           value="{{ index .Data.Settings "body_text_length" }}" 
                           min="50" max="1000" required>
                    <div class="help-text">
                        Number of characters to show in the entry preview (50-1000 characters).
                    </div>
                </div>
            </div>
            
            <!-- Entry Filtering moved to dedicated Filters page -->
            <div class="setting-group">
                <label>ENTRY FILTERING</label>
                <div class="help-text">Filters are managed on the dedicated Filters page.</div>
                <a href="/admin/filters-page" class="action-btn primary">OPEN FILTERS</a>
            </div>
            
            <div class="setting-group backup-section">
                <h3>BACKUP & RESTORE</h3>
                <div class="form-row">
                    <div>
                        <label class="checkbox-label" for="backupEnabled">
                            <input type="checkbox" id="backupEnabled" name="backupEnabled" {{ if eq (index .Data.Settings "backup_enabled") "true" }}checked{{ end }}>
                            Enable Auto Backups
                        </label>
                        <div class="help-text">Automatically create backups on a schedule</div>
                    </div>
                    <div>
                        <label for="backupIntervalHours">INTERVAL (HOURS)</label>
                        <input type="number" id="backupIntervalHours" name="backupIntervalHours" value="{{ getSetting .Data.Settings "backup_interval_hours" "24" }}" min="1">
                    </div>
                    <div>
                        <label for="backupRetentionDays">RETENTION (DAYS)</label>
                        <input type="number" id="backupRetentionDays" name="backupRetentionDays" value="{{ getSetting .Data.Settings "backup_retention_days" "30" }}" min="1">
                    </div>
                </div>
                <div class="backup-actions">
                    <button type="button" data-action="export-backup" class="backup-button export">EXPORT BACKUP</button>
                    <div class="import-container">
                        <input type="file" id="importFile" accept=".json" class="hidden">
                        <button type="button" data-action="trigger-import" class="backup-button import">IMPORT BACKUP</button>
                    </div>
                </div>
                <div class="setting-group">
                    <label>AVAILABLE BACKUPS</label>
                    <div id="backupList" class="backup-list"></div>
                    <div class="help-text">Backups stored in the server's backup directory are listed here.</div>
                </div>
                <div class="backup-actions">
                    <button type="button" id="createServerBackup" class="backup-button">CREATE SERVER BACKUP NOW</button>
                </div>
                <div id="backupStatus" class="backup-status"></div>
            </div>
            <button type="submit" class="submit-button">SAVE SETTINGS</button>
            <div id="status" class="status"></div>
        </form>
    </div>

    <!-- Password Change Panel -->
    <div class="panel" id="passwordPanel">
        <h3>CHANGE PASSWORD</h3>
        <form id="passwordChangeForm" method="POST">
            <div class="setting-group">
                <label for="currentPassword">CURRENT PASSWORD</label>
                <input type="password" id="currentPassword" name="currentPassword" required>
            </div>
            <div class="setting-group">
                <label for="newPassword">NEW PASSWORD</label>
                <input type="password" id="newPassword" name="newPassword" required minlength="8">
                 <div class="help-text">Minimum 8 characters required.</div>
            </div>
            <div class="setting-group">
                <label for="confirmNewPassword">CONFIRM NEW PASSWORD</label>
                <input type="password" id="confirmNewPassword" name="confirmNewPassword" required minlength="8">
            </div>
            <button type="submit" class="submit-button">CHANGE PASSWORD</button>
            <div id="passwordChangeStatus" class="status"></div>
        </form>
    </div>
</div>
{{ end }}
{{ define "styles" }}
<link rel="stylesheet" href="{{ themeCSSAdmin .Data.Settings "settings.css" }}">
{{ end }}
{{ define "scripts" }}
<script type="module" src="/static/js/modules/settings.js"></script>
<script>
// Settings Form Handler
function initializeSettingsForm() {
    const settingsForm = document.getElementById('settingsForm');
    if (!settingsForm) return;
    
    settingsForm.addEventListener('submit', async (e) => {
        e.preventDefault();
        
        try {
            // Handle image uploads first
            const imageInput = document.getElementById('footerImage');
            const faviconInput = document.getElementById('favicon');
            const metaImageInput = document.getElementById('metaImage');
            
            let imageFilename = '{{ index .Data.Settings "footer_image_url" }}';
            let faviconFilename = '{{ index .Data.Settings "favicon_url" }}';
            let metaImageFilename = '{{ index .Data.Settings "meta_image_url" }}';
            
            // Upload footer image if selected
            if (imageInput && imageInput.files && imageInput.files[0]) {
                const imageFormData = new FormData();
                imageFormData.append('image', imageInput.files[0]);
                
                const imageResponse = await fetch('/admin/upload-image', {
                    method: 'POST',
                    headers: {
                        'X-CSRF-Token': '{{ .CSRFToken }}'
                    },
                    body: imageFormData
                });
                
                if (imageResponse.ok) {
                    const imageResult = await imageResponse.json();
                    imageFilename = imageResult.filename;
                } else {
                    const imageError = await imageResponse.text();
                    throw new Error(`Image upload failed: ${imageError}`);
                }
            }
            
            // Upload favicon if selected
            if (faviconInput && faviconInput.files && faviconInput.files[0]) {
                const faviconFormData = new FormData();
                faviconFormData.append('favicon', faviconInput.files[0]);
                
                const faviconResponse = await fetch('/admin/upload-favicon', {
                    method: 'POST',
                    headers: {
                        'X-CSRF-Token': '{{ .CSRFToken }}'
                    },
                    body: faviconFormData
                });
                
                if (faviconResponse.ok) {
                    const faviconResult = await faviconResponse.json();
                    faviconFilename = faviconResult.filename;
                } else {
                    const faviconError = await faviconResponse.text();
                    throw new Error(`Favicon upload failed: ${faviconError}`);
                }
            }
            
            // Upload meta image if selected
            if (metaImageInput && metaImageInput.files && metaImageInput.files[0]) {
                const metaImageFormData = new FormData();
                metaImageFormData.append('image', metaImageInput.files[0]);
                
                const metaImageResponse = await fetch('/admin/upload-meta-image', {
                    method: 'POST',
                    headers: {
                        'X-CSRF-Token': '{{ .CSRFToken }}'
                    },
                    body: metaImageFormData
                });
                
                if (metaImageResponse.ok) {
                    const metaImageResult = await metaImageResponse.json();
                    metaImageFilename = metaImageResult.filename;
                } else {
                    const metaImageError = await metaImageResponse.text();
                    throw new Error(`Meta image upload failed: ${metaImageError}`);
                }
            }
            
            // Prepare settings data
            const formData = new FormData(document.getElementById('settingsForm'));
            const settings = {};
            
            // Map form field names to JSON field names expected by Go backend
            const fieldMapping = {
                'show_blog_name': 'showBlogName',
                'show_body_text': 'showBodyText',
                'body_text_length': 'bodyTextLength',
                'allow_public_theme_selection': 'allowPublicThemeSelection'
            };
            
            // Handle multiple checkbox values for themes
            const publicAvailableThemes = [];
            for (let [key, value] of formData.entries()) {
                if (key === 'public_available_themes') {
                    publicAvailableThemes.push(value);
                }
            }
            if (publicAvailableThemes.length > 0) {
                settings.publicAvailableThemes = publicAvailableThemes.join(',');
            }
            
            for (let [key, value] of formData.entries()) {
                if (key !== 'image' && key !== 'favicon' && key !== 'footerImage' && key !== 'metaImage' && key !== 'public_available_themes') {
                    // Map field name if needed
                    const jsonKey = fieldMapping[key] || key;
                    
                    // Handle checkbox values (convert to boolean)
                    if (key === 'show_blog_name' || key === 'show_body_text' || key === 'allow_public_theme_selection') {
                        settings[jsonKey] = true; // Checkbox is checked if present in formData
                    }
                    // Handle numeric values
                    else if (key === 'maxPosts' || key === 'updateInterval' || key === 'body_text_length') {
                        settings[jsonKey] = parseInt(value, 10) || 0;
                    }
                    // Handle string values
                    else {
                        settings[jsonKey] = value;
                    }
                }
            }
            
            // Handle unchecked checkboxes (they won't be in formData)
            if (!formData.has('show_blog_name')) {
                settings['showBlogName'] = false;
            }
            if (!formData.has('show_body_text')) {
                settings['showBodyText'] = false;
            }
            if (!formData.has('allow_public_theme_selection')) {
                settings['allowPublicThemeSelection'] = false;
            }
            
            // Override with uploaded filenames
            settings.footerImageURL = imageFilename;
            settings.faviconURL = faviconFilename;
            settings.metaImageURL = metaImageFilename;
            
            // Save settings
            const response = await fetch('/admin/settings', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRF-Token': '{{ .CSRFToken }}'
                },
                body: JSON.stringify(settings)
            });
            
            if (response.ok) {
                showNotification('Settings saved successfully!', 'success');
            } else {
                const error = await response.text();
                showNotification(`Error saving settings: ${error}`, 'error');
            }
            
        } catch (error) {
            showNotification(`Error: ${error.message}`, 'error');
        }
    });
}

// Password Form Handler
function initializePasswordForm() {
    const passwordForm = document.getElementById('passwordChangeForm');
    if (!passwordForm) return;
    
    passwordForm.addEventListener('submit', async (e) => {
        e.preventDefault();
        
        const currentPassword = document.getElementById('currentPassword').value;
        const newPassword = document.getElementById('newPassword').value;
        const confirmNewPassword = document.getElementById('confirmNewPassword').value;
        
        if (newPassword !== confirmNewPassword) {
            showNotification('New passwords do not match.', 'error');
            return;
        }
        
        if (newPassword.length < 8) {
            showNotification('New password must be at least 8 characters long.', 'error');
            return;
        }
        
        try {
            const response = await fetch('/admin/change-password', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRF-Token': '{{ .CSRFToken }}'
                },
                body: JSON.stringify({
                    currentPassword: currentPassword,
                    newPassword: newPassword
                })
            });
            
            if (response.ok) {
                showNotification('Password changed successfully!', 'success');
                passwordForm.reset();
            } else {
                const error = await response.text();
                showNotification(error, 'error');
            }
        } catch (error) {
            showNotification(`Error: ${error.message}`, 'error');
        }
    });
}

// Image Upload Handlers
function initializeImageUploads() {
    const fileInputs = ['footerImage', 'favicon', 'metaImage'];
    
    fileInputs.forEach(inputId => {
        const input = document.getElementById(inputId);
        if (input) {
            input.addEventListener('change', function(e) {
                const file = e.target.files[0];
                const previewId = inputId + 'Preview'; 
                const statusId = inputId + 'Status';
                
                const preview = document.getElementById(previewId);
                const status = document.getElementById(statusId);
                
                if (file) {
                    // Validate file size (1MB max)
                    if (file.size > 1024 * 1024) {
                        if (status) {
                            status.className = 'image-upload-status error';
                            status.textContent = 'File size must be less than 1MB';
                        }
                        input.value = '';
                        return;
                    }
                    
                    // Validate file type
                    const validTypes = inputId === 'favicon' 
                        ? ['image/x-icon', 'image/vnd.microsoft.icon', 'image/png']
                        : ['image/jpeg', 'image/jpg', 'image/png', 'image/gif', 'image/webp'];
                        
                    if (!validTypes.includes(file.type)) {
                        if (status) {
                            status.className = 'image-upload-status error';
                            status.textContent = inputId === 'favicon' 
                                ? 'Please select an ICO or PNG file'
                                : 'Please select a valid image file';
                        }
                        input.value = '';
                        return;
                    }
                    
                    // Show success status
                    if (status) {
                        status.className = 'image-upload-status success';
                        status.textContent = `Selected: ${file.name}`;
                    }
                    
                    // Show preview
                    if (preview) {
                        preview.style.display = 'block';
                        const img = preview.querySelector('img');
                        if (img) {
                            const reader = new FileReader();
                            reader.onload = function(e) {
                                img.src = e.target.result;
                            };
                            reader.readAsDataURL(file);
                        }
                    }
                } else {
                    // Clear preview and status
                    if (preview) preview.style.display = 'none';
                    if (status) {
                        status.className = 'image-upload-status';
                        status.textContent = '';
                    }
                }
            });
        }
    });
}

// Backup System
function initializeBackupSystem() {
    // Export backup functionality is handled by the global function
    // Import is handled by the global handleImport function
}

// === FILTER MANAGEMENT SYSTEM ===
let currentEditingGroupId = null;
let currentEditingFilterId = null;
let currentDeletingFilterId = null;
let currentDeletingGroupId = null;
let availableFilters = [];

function initializeFilterSystem() {
    // Setup modal handlers
    setupModalHandlers();
    
    // Setup drag and drop
    setupDragAndDrop();
    
    // Setup operator change handlers
    setupOperatorChangeHandlers();
    
    // Load filters data
    loadFiltersData();
    
    // Load categories for filter group options
    loadCategories();
}

function setupModalHandlers() {
    // Close modals when clicking outside
    window.addEventListener('click', function(e) {
        if (e.target.classList.contains('modal')) {
            closeModal(e.target.id);
        }
    });
    
    // Close modals with Escape key
    document.addEventListener('keydown', function(e) {
        if (e.key === 'Escape') {
            const openModal = document.querySelector('.modal.show');
            if (openModal) {
                closeModal(openModal.id);
            }
        }
    });
}

function setupDragAndDrop() {
    const filterCards = document.querySelectorAll('.filter-card');
    
    filterCards.forEach(card => {
        card.addEventListener('dragstart', handleDragStart);
        card.addEventListener('dragend', handleDragEnd);
    });
    
    const groupCards = document.querySelectorAll('.filter-group-card');
    groupCards.forEach(group => {
        group.addEventListener('dragover', handleDragOver);
        group.addEventListener('drop', handleDrop);
    });
}

function setupOperatorChangeHandlers() {
    // Use event delegation to handle operator changes for dynamically created elements
    document.addEventListener('change', function(e) {
        if (e.target.classList.contains('assignment-operator')) {
            const filterId = e.target.dataset.filterId;
            const newOperator = e.target.value;
            updateFilterOperator(filterId, newOperator);
        }
    });
}

function handleDragStart(e) {
    e.dataTransfer.setData('text/plain', e.target.dataset.filterId);
    e.target.style.opacity = '0.5';
}

function handleDragEnd(e) {
    e.target.style.opacity = '1';
}

function handleDragOver(e) {
    e.preventDefault();
    e.currentTarget.style.borderColor = '#67bb79';
}

function handleDrop(e) {
    e.preventDefault();
    e.currentTarget.style.borderColor = '#2a3450';
    
    const filterId = e.dataTransfer.getData('text/plain');
    const groupId = e.currentTarget.dataset.groupId;
    
    if (filterId && groupId) {
        addFilterToGroup(filterId, groupId);
    }
}

async function loadFiltersData() {
    try {
        const response = await fetch('/admin/filters');
        if (response.ok) {
            availableFilters = await response.json();
        }
    } catch (error) {
        console.error('Error loading filters:', error);
    }
}

async function loadCategories() {
    try {
        const response = await fetch('/admin/api/categories');
        if (response.ok) {
            const data = await response.json();
            const categories = data.categories || [];
            
            // Populate create group dropdown
            const createSelect = document.getElementById('modalGroupCategory');
            createSelect.innerHTML = '<option value="">All categories</option>';
            categories.forEach(category => {
                const option = document.createElement('option');
                option.value = category;
                option.textContent = category;
                createSelect.appendChild(option);
            });
            
            // Populate edit group dropdown
            const editSelect = document.getElementById('editGroupCategory');
            editSelect.innerHTML = '<option value="">All categories</option>';
            categories.forEach(category => {
                const option = document.createElement('option');
                option.value = category;
                option.textContent = category;
                editSelect.appendChild(option);
            });
        }
    } catch (error) {
        console.error('Error loading categories:', error);
    }
}

// Modal Functions
function showCreateGroupModal() {
    console.log('showCreateGroupModal called');
    const modal = document.getElementById('createGroupModal');
    console.log('Modal element found:', !!modal);
    if (modal) {
        console.log('Adding show class to modal');
        modal.classList.add('show');
        console.log('Modal classes after adding show:', modal.className);
        const nameInput = document.getElementById('modalGroupName');
        if (nameInput) {
            nameInput.focus();
        }
    } else {
        console.error('createGroupModal element not found');
    }
}

function showCreateFilterModal() {
    console.log('showCreateFilterModal called');
    const modal = document.getElementById('createFilterModal');
    console.log('Modal element found:', !!modal);
    if (modal) {
        console.log('Adding show class to modal');
        modal.classList.add('show');
        console.log('Modal classes after adding show:', modal.className);
        const nameInput = document.getElementById('modalFilterName');
        if (nameInput) {
            nameInput.focus();
        }
    } else {
        console.error('createFilterModal element not found');
    }
}

function closeModal(modalId) {
    document.getElementById(modalId).classList.remove('show');
    
    // Reset form fields
    const modal = document.getElementById(modalId);
    const inputs = modal.querySelectorAll('input, select');
    inputs.forEach(input => {
        if (input.type === 'checkbox') {
            input.checked = input.id === 'modalGroupActive';
        } else if (input.type === 'number') {
            input.value = input.id === 'modalGroupPriority' ? '0' : '';
        } else {
            input.value = '';
        }
    });
    
    // Clear editing states
    if (modalId === 'editGroupModal') {
        currentEditingGroupId = null;
    }
    if (modalId === 'editFilterModal') {
        currentEditingFilterId = null;
    }
    if (modalId === 'deleteFilterModal') {
        currentDeletingFilterId = null;
    }
    if (modalId === 'deleteGroupModal') {
        currentDeletingGroupId = null;
    }
}

// Group Management Functions
async function saveGroup() {
    const name = document.getElementById('modalGroupName').value.trim();
    const action = document.getElementById('modalGroupAction').value;
    const priority = parseInt(document.getElementById('modalGroupPriority').value) || 0;
    const category = document.getElementById('modalGroupCategory').value.trim();
    const isActive = document.getElementById('modalGroupActive').checked;
    
    if (!name) {
        showNotification('Please enter a group name', 'error');
        return;
    }
    
    try {
        const response = await fetch('/admin/filter-groups', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRF-Token': '{{ .CSRFToken }}'
            },
            body: JSON.stringify({
                name: name,
                action: action,
                priority: priority,
                apply_to_category: category,
                is_active: isActive
            })
        });
        
        if (response.ok) {
            showNotification('Filter group created successfully', 'success');
            closeModal('createGroupModal');
            setTimeout(() => location.reload(), 3000);
        } else {
            const error = await response.text();
            showNotification(`Error creating group: ${error}`, 'error');
        }
    } catch (error) {
        showNotification(`Error creating group: ${error.message}`, 'error');
    }
}

async function editGroup(groupId) {
    currentEditingGroupId = groupId;
    
    try {
        const response = await fetch(`/admin/filter-groups/${groupId}`);
        if (!response.ok) {
            throw new Error('Failed to fetch group data');
        }
        
        const result = await response.json();
        const group = result.data || result;
        
        // Populate form
        document.getElementById('editGroupName').value = group.name;
        document.getElementById('editGroupAction').value = group.action;
        document.getElementById('editGroupPriority').value = group.priority;
        document.getElementById('editGroupCategory').value = group.apply_to_category || '';
        document.getElementById('editGroupActive').checked = group.is_active;
        
        // Update modal title
        document.getElementById('editGroupModalTitle').textContent = `Edit Filter Group: ${group.name}`;
        
        // Load filters for assignment
        await loadFiltersForAssignment(groupId);
        
        // Setup drag and drop for assigned filters
        setupAssignedFiltersDragAndDrop();
        
        // Show modal
        document.getElementById('editGroupModal').classList.add('show');
        
    } catch (error) {
        showNotification(`Error loading group: ${error.message}`, 'error');
    }
}

async function updateGroup() {
    if (!currentEditingGroupId) return;
    
    const name = document.getElementById('editGroupName').value.trim();
    const action = document.getElementById('editGroupAction').value;
    const priority = parseInt(document.getElementById('editGroupPriority').value) || 0;
    const category = document.getElementById('editGroupCategory').value.trim();
    const isActive = document.getElementById('editGroupActive').checked;
    
    if (!name) {
        showNotification('Please enter a group name', 'error');
        return;
    }
    
    // Collect the current filter arrangement and operators
    const assignedContainer = document.getElementById('assignedFilters');
    const filterItems = [...assignedContainer.querySelectorAll('.filter-assignment-item')];
    const rules = [];
    
    filterItems.forEach((item, index) => {
        const filterId = parseInt(item.dataset.filterId);
        const operatorSelect = item.querySelector('.assignment-operator');
        const operator = operatorSelect ? operatorSelect.value : 'AND';
        
        // First filter doesn't need an operator, subsequent ones do
        rules.push({
            filter_id: filterId,
            operator: index === 0 ? 'AND' : operator, // First rule uses AND by default
            position: index
        });
    });
    
    console.log('Saving group with rules:', rules);
    
    try {
        // First, update the group information
        const groupResponse = await fetch(`/admin/filter-groups/${currentEditingGroupId}`, {
            method: 'PUT',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRF-Token': '{{ .CSRFToken }}'
            },
            body: JSON.stringify({
                name: name,
                action: action,
                priority: priority,
                apply_to_category: category,
                is_active: isActive
            })
        });
        
        console.log('Group update response status:', groupResponse.status);
        
        if (!groupResponse.ok) {
            const error = await groupResponse.text();
            throw new Error(`Failed to update group: ${error}`);
        }
        
        // Second, update the filter rules (order and operators)
        const rulesResponse = await fetch(`/admin/filter-groups/${currentEditingGroupId}/rules`, {
            method: 'PUT',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRF-Token': '{{ .CSRFToken }}'
            },
            body: JSON.stringify({
                rules: rules
            })
        });
        
        console.log('Rules update response status:', rulesResponse.status);
        
        if (!rulesResponse.ok) {
            const error = await rulesResponse.text();
            throw new Error(`Failed to update rules: ${error}`);
        }
        
        showNotification('Filter group updated successfully', 'success');
        closeModal('editGroupModal');
        setTimeout(() => location.reload(), 1000);
        
    } catch (error) {
        console.error('Update failed:', error);
        showNotification(`Error updating group: ${error.message}`, 'error');
    }
}

async function toggleGroup(groupId, currentStatus) {
    try {
        // First fetch the current group data
        const getResponse = await fetch(`/admin/filter-groups/${groupId}`);
        if (!getResponse.ok) {
            throw new Error('Failed to fetch group data');
        }
        
        const result = await getResponse.json();
        const group = result.data;
        
        // Update with toggled status
        const response = await fetch(`/admin/filter-groups/${groupId}`, {
            method: 'PUT',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRF-Token': '{{ .CSRFToken }}'
            },
            body: JSON.stringify({
                name: group.name,
                action: group.action,
                priority: group.priority,
                is_active: !currentStatus
            })
        });
        
        if (response.ok) {
            location.reload();
        } else {
            const error = await response.text();
            showNotification(`Error toggling group: ${error}`, 'error');
        }
    } catch (error) {
        showNotification(`Error toggling group: ${error.message}`, 'error');
    }
}

async function deleteGroup(groupId) {
    try {
        // Fetch the group data to show in the confirmation modal
        const response = await fetch(`/admin/filter-groups/${groupId}`);
        if (!response.ok) {
            throw new Error('Failed to fetch group data');
        }
        
        const result = await response.json();
        const group = result.data;
        
        // Populate the delete modal with group info
        const groupInfo = document.getElementById('deleteGroupInfo');
        groupInfo.innerHTML = `
            <h5>${group.name}</h5>
            <div class="description">
                Action: <span class="action-badge ${group.action}">${group.action.toUpperCase()}</span> | 
                Priority: <span class="priority-badge">P${group.priority}</span>
            </div>
        `;
        
        // Store the group ID for the confirmation function
        currentDeletingGroupId = groupId;
        
        // Show the modal
        document.getElementById('deleteGroupModal').classList.add('show');
        
    } catch (error) {
        showNotification(`Error loading group: ${error.message}`, 'error');
    }
}

async function confirmDeleteGroup() {
    if (!currentDeletingGroupId) {
        showNotification('No group selected for deletion', 'error');
        return;
    }
    
    try {
        const response = await fetch(`/admin/filter-groups/${currentDeletingGroupId}`, {
            method: 'DELETE',
            headers: {
                'X-CSRF-Token': '{{ .CSRFToken }}'
            }
        });
        
        if (response.ok) {
            showNotification('Filter group deleted successfully', 'success');
            closeModal('deleteGroupModal');
            currentDeletingGroupId = null;
            setTimeout(() => location.reload(), 3000);
        } else {
            const error = await response.text();
            showNotification(`Error deleting group: ${error}`, 'error');
        }
    } catch (error) {
        showNotification(`Error deleting group: ${error.message}`, 'error');
    }
}

// Filter Management Functions
async function saveFilter() {
    const name = document.getElementById('modalFilterName').value.trim();
    const pattern = document.getElementById('modalFilterPattern').value.trim();
    const type = document.getElementById('modalFilterType').value;
    const targetType = document.getElementById('modalFilterTargetType').value;
    const caseSensitive = document.getElementById('modalFilterCaseSensitive').checked;
    
    if (!name || !pattern) {
        showNotification('Please enter both name and pattern', 'error');
        return;
    }
    
    try {
        const response = await fetch('/admin/filters', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRF-Token': '{{ .CSRFToken }}'
            },
            body: JSON.stringify({
                name: name,
                pattern: pattern,
                pattern_type: type,
                target_type: targetType,
                case_sensitive: caseSensitive
            })
        });
        
        if (response.ok) {
            showNotification('Filter created successfully', 'success');
            closeModal('createFilterModal');
            setTimeout(() => location.reload(), 3000);
        } else {
            const error = await response.text();
            showNotification(`Error creating filter: ${error}`, 'error');
        }
    } catch (error) {
        showNotification(`Error creating filter: ${error.message}`, 'error');
    }
}

async function editFilter(filterId) {
    console.log('editFilter called with filterId:', filterId);
    try {
        // Fetch the filter data
        const response = await fetch(`/admin/filters/${filterId}`);
        console.log('Response status:', response.status);
        if (!response.ok) {
            throw new Error('Failed to fetch filter data');
        }
        
        const result = await response.json();
        console.log('Filter data received:', result);
        const filter = result.data;
        
        // Check if modal elements exist
        const modal = document.getElementById('editFilterModal');
        console.log('Modal element found:', modal);
        const nameField = document.getElementById('editFilterName');
        console.log('Name field found:', nameField);
        
        // Populate the edit modal with current values
        if (nameField) nameField.value = filter.name;
        const patternField = document.getElementById('editFilterPattern');
        if (patternField) patternField.value = filter.pattern;
        const typeField = document.getElementById('editFilterType');
        if (typeField) typeField.value = filter.pattern_type;
        const targetField = document.getElementById('editFilterTargetType');
        if (targetField) targetField.value = filter.target_type || 'title';
        const caseSensitiveField = document.getElementById('editFilterCaseSensitive');
        if (caseSensitiveField) caseSensitiveField.checked = filter.case_sensitive;
        
        // Store the filter ID for the update function
        currentEditingFilterId = filterId;
        
        // Show the modal
        if (modal) {
            modal.classList.add('show');
            console.log('Modal show class added');
            if (nameField) nameField.focus();
        } else {
            console.error('Modal element not found!');
        }
        
    } catch (error) {
        console.error('Error in editFilter:', error);
        showNotification(`Error loading filter: ${error.message}`, 'error');
    }
}

async function updateFilter() {
    const name = document.getElementById('editFilterName').value.trim();
    const pattern = document.getElementById('editFilterPattern').value.trim();
    const type = document.getElementById('editFilterType').value;
    const targetType = document.getElementById('editFilterTargetType').value;
    const caseSensitive = document.getElementById('editFilterCaseSensitive').checked;
    
    if (!name || !pattern) {
        showNotification('Please enter both name and pattern', 'error');
        return;
    }
    
    if (!currentEditingFilterId) {
        showNotification('No filter selected for editing', 'error');
        return;
    }
    
    try {
        const response = await fetch(`/admin/filters/${currentEditingFilterId}`, {
            method: 'PUT',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRF-Token': '{{ .CSRFToken }}'
            },
            body: JSON.stringify({
                name: name,
                pattern: pattern,
                pattern_type: type,
                target_type: targetType,
                case_sensitive: caseSensitive
            })
        });
        
        if (response.ok) {
            showNotification('Filter updated successfully', 'success');
            closeModal('editFilterModal');
            currentEditingFilterId = null;
            setTimeout(() => location.reload(), 3000);
        } else {
            const error = await response.text();
            showNotification(`Error updating filter: ${error}`, 'error');
        }
    } catch (error) {
        showNotification(`Error updating filter: ${error.message}`, 'error');
    }
}

async function deleteFilter(filterId) {
    try {
        // Fetch the filter data to show in the confirmation modal
        const response = await fetch(`/admin/filters/${filterId}`);
        if (!response.ok) {
            throw new Error('Failed to fetch filter data');
        }
        
        const result = await response.json();
        const filter = result.data;
        
        // Populate the delete modal with filter info
        const filterInfo = document.getElementById('deleteFilterInfo');
        filterInfo.innerHTML = `
            <h5>${filter.name}</h5>
            <div class="pattern">${filter.pattern}</div>
            <div class="filter-meta">
                <span class="type-badge ${filter.pattern_type}">${filter.pattern_type.toUpperCase()}</span>
                ${filter.case_sensitive ? '<span class="feature-badge">Case Sensitive</span>' : ''}
            </div>
        `;
        
        // Store the filter ID for the confirmation function
        currentDeletingFilterId = filterId;
        
        // Show the modal
        document.getElementById('deleteFilterModal').classList.add('show');
        
    } catch (error) {
        showNotification(`Error loading filter: ${error.message}`, 'error');
    }
}

async function confirmDeleteFilter() {
    if (!currentDeletingFilterId) {
        showNotification('No filter selected for deletion', 'error');
        return;
    }
    
    try {
        const response = await fetch(`/admin/filters/${currentDeletingFilterId}`, {
            method: 'DELETE',
            headers: {
                'X-CSRF-Token': '{{ .CSRFToken }}'
            }
        });
        
        if (response.ok) {
            showNotification('Filter deleted successfully', 'success');
            closeModal('deleteFilterModal');
            currentDeletingFilterId = null;
            setTimeout(() => location.reload(), 3000);
        } else {
            const error = await response.text();
            showNotification(`Error deleting filter: ${error}`, 'error');
        }
    } catch (error) {
        showNotification(`Error deleting filter: ${error.message}`, 'error');
    }
}

// Filter Assignment Functions
async function loadFiltersForAssignment(groupId) {
    try {
        // Load all filters
        const filtersResponse = await fetch('/admin/filters');
        const filtersResult = await filtersResponse.json();
        availableFilters = filtersResult.data || filtersResult;
        
        // Load group rules
        const rulesResponse = await fetch(`/admin/filter-groups/${groupId}/rules`);
        const rulesResult = await rulesResponse.json();
        const groupRules = rulesResult.data || rulesResult;
        
        renderFilterAssignment(groupRules);
        
    } catch (error) {
        showNotification(`Error loading filters: ${error.message}`, 'error');
    }
}

function renderFilterAssignment(assignedRules) {
    const assignedContainer = document.getElementById('assignedFilters');
    const availableContainer = document.getElementById('availableFilters');
    
    if (!assignedContainer || !availableContainer) return;
    
    // Clear containers
    assignedContainer.innerHTML = '';
    availableContainer.innerHTML = '';
    
    // Ensure assignedRules is an array
    if (!Array.isArray(assignedRules)) {
        assignedRules = [];
    }
    
    // Get assigned filter IDs
    const assignedIds = assignedRules.map(rule => rule.filter_id);
    
    // Render assigned filters
    assignedRules.forEach((rule, index) => {
        const filter = availableFilters.find(f => f.id === rule.filter_id);
        if (filter) {
            assignedContainer.appendChild(createAssignmentItem(filter, true, rule.operator, index));
        }
    });
    
    // Render available filters
    availableFilters.forEach(filter => {
        if (!assignedIds.includes(filter.id)) {
            availableContainer.appendChild(createAssignmentItem(filter, false));
        }
    });
    
    if (assignedContainer.children.length === 0) {
        assignedContainer.innerHTML = '<div class="empty-state small">No filters assigned</div>';
    }
    
    if (availableContainer.children.length === 0) {
        availableContainer.innerHTML = '<div class="empty-state small">No available filters</div>';
    }
}

function createAssignmentItem(filter, isAssigned, operator = 'AND', position = 0) {
    const item = document.createElement('div');
    item.className = 'filter-assignment-item';
    item.dataset.filterId = filter.id;
    
    // Make assigned filters draggable
    if (isAssigned) {
        item.draggable = true;
        item.classList.add('draggable');
        item.addEventListener('dragstart', handleFilterDragStart);
        item.addEventListener('dragend', handleFilterDragEnd);
    }
    
    // For assigned filters, show operator before the filter (except for the first one)
    const operatorHTML = isAssigned && position > 0 ? `
        <div class="logic-operator-section">
            <select class="assignment-operator" data-filter-id="${filter.id}">
                <option value="AND" ${operator === 'AND' ? 'selected' : ''}>AND</option>
                <option value="OR" ${operator === 'OR' ? 'selected' : ''}>OR</option>
            </select>
        </div>
    ` : '';
    
    // Add drag handle for assigned filters
    const dragHandleHTML = isAssigned ? `
        <div class="drag-handle" title="Drag to reorder">
            <span>â®â®</span>
        </div>
    ` : '';
    
    item.innerHTML = `
        ${dragHandleHTML}
        ${operatorHTML}
        <div class="assignment-info">
            <div class="assignment-name">${filter.name}</div>
            <div class="assignment-pattern">${filter.pattern}</div>
        </div>
        <div class="assignment-actions">
            ${isAssigned ? `
                <button class="assignment-btn" data-action="remove-filter-from-group" data-filter-id="${filter.id}">Remove</button>
            ` : `
                <button class="assignment-btn primary" data-action="add-filter-to-group" data-filter-id="${filter.id}" data-group-id="${currentEditingGroupId}">Add</button>
            `}
        </div>
    `;
    
    return item;
}

async function addFilterToGroup(filterId, groupId) {
    try {
        // First, get current rules
        const rulesResponse = await fetch(`/admin/filter-groups/${groupId}/rules`);
        const rulesResult = await rulesResponse.json();
        const currentRules = rulesResult.data || rulesResult || [];
        
        // Debug logging
        console.log('Rules response:', rulesResponse.ok);
        console.log('Rules result:', rulesResult);
        console.log('Current rules:', currentRules);
        console.log('Is array?', Array.isArray(currentRules));
        
        // Ensure currentRules is an array
        const rulesArray = Array.isArray(currentRules) ? currentRules : [];
        
        // Check if filter is already assigned
        if (rulesArray.some(rule => rule.filter_id === parseInt(filterId))) {
            showNotification('Filter already assigned to this group', 'error');
            return;
        }
        
        // Add the new rule
        const newRules = [
            ...rulesArray.map((rule, index) => ({
                filter_id: rule.filter_id,
                operator: rule.operator,
                position: index
            })),
            {
                filter_id: parseInt(filterId),
                operator: rulesArray.length === 0 ? 'AND' : 'OR', // First filter gets 'AND', subsequent ones default to 'OR'
                position: rulesArray.length
            }
        ];
        
        // Update the group rules
        const response = await fetch(`/admin/filter-groups/${groupId}/rules`, {
            method: 'PUT',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRF-Token': '{{ .CSRFToken }}'
            },
            body: JSON.stringify({
                rules: newRules
            })
        });
        
        if (response.ok) {
            showNotification('Filter added to group', 'success');
            if (currentEditingGroupId) {
                await loadFiltersForAssignment(currentEditingGroupId);
            }
        } else {
            const error = await response.text();
            showNotification(`Error adding filter: ${error}`, 'error');
        }
    } catch (error) {
        showNotification(`Error adding filter: ${error.message}`, 'error');
    }
}

async function updateFilterOperator(filterId, newOperator) {
    if (!currentEditingGroupId) return;
    
    try {
        // Validate operator
        if (newOperator !== 'AND' && newOperator !== 'OR') {
            showNotification('Invalid operator. Must be AND or OR.', 'error');
            return;
        }
        
        // Get current rules
        const rulesResponse = await fetch(`/admin/filter-groups/${currentEditingGroupId}/rules`);
        if (!rulesResponse.ok) {
            throw new Error(`Failed to fetch current rules: ${rulesResponse.status}`);
        }
        
        const rulesResult = await rulesResponse.json();
        const currentRules = rulesResult.data || rulesResult || [];
        const rulesArray = Array.isArray(currentRules) ? currentRules : [];
        
        // Find and update the operator for the specific filter
        const updatedRules = rulesArray.map((rule, index) => ({
            filter_id: rule.filter_id,
            operator: rule.filter_id === parseInt(filterId) ? newOperator : rule.operator,
            position: index
        }));
        
        // Validate that we found the filter to update
        const foundFilter = updatedRules.find(rule => rule.filter_id === parseInt(filterId));
        if (!foundFilter) {
            throw new Error('Filter not found in group rules');
        }
        
        // Save the updated rules
        const response = await fetch(`/admin/filter-groups/${currentEditingGroupId}/rules`, {
            method: 'PUT',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRF-Token': '{{ .CSRFToken }}'
            },
            body: JSON.stringify({
                rules: updatedRules
            })
        });
        
        if (response.ok) {
            showNotification(`Operator updated to ${newOperator}`, 'success');
        } else {
            const errorText = await response.text();
            throw new Error(errorText || `Server error: ${response.status}`);
        }
    } catch (error) {
        console.error('Error updating operator:', error);
        showNotification(`Error updating operator: ${error.message}`, 'error');
        // Reload the assignment view to revert the dropdown
        if (currentEditingGroupId) {
            await loadFiltersForAssignment(currentEditingGroupId);
        }
    }
}

async function removeFilterFromGroup(filterId) {
    if (!currentEditingGroupId) return;
    
    try {
        // First, get current rules
        const rulesResponse = await fetch(`/admin/filter-groups/${currentEditingGroupId}/rules`);
        const rulesResult = await rulesResponse.json();
        const currentRules = rulesResult.data || rulesResult || [];
        
        // Ensure currentRules is an array
        const rulesArray = Array.isArray(currentRules) ? currentRules : [];
        
        // Remove the filter and update positions
        const newRules = rulesArray
            .filter(rule => rule.filter_id !== parseInt(filterId))
            .map((rule, index) => ({
                filter_id: rule.filter_id,
                operator: rule.operator,
                position: index
            }));
        
        // Update the group rules
        const response = await fetch(`/admin/filter-groups/${currentEditingGroupId}/rules`, {
            method: 'PUT',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRF-Token': '{{ .CSRFToken }}'
            },
            body: JSON.stringify({
                rules: newRules
            })
        });
        
        if (response.ok) {
            showNotification('Filter removed from group', 'success');
            await loadFiltersForAssignment(currentEditingGroupId);
        } else {
            const error = await response.text();
            showNotification(`Error removing filter: ${error}`, 'error');
        }
    } catch (error) {
        showNotification(`Error removing filter: ${error.message}`, 'error');
    }
}

async function addFiltersToGroup(groupId) {
    currentEditingGroupId = groupId;
    
    try {
        // Fetch group data to get the name
        const groupResponse = await fetch(`/admin/filter-groups/${groupId}`);
        if (!groupResponse.ok) {
            throw new Error('Failed to fetch group data');
        }
        
        const groupResult = await groupResponse.json();
        const group = groupResult.data || groupResult;
        
        // Update modal title
        document.getElementById('editGroupModalTitle').textContent = `Add Filters to Group: ${group.name}`;
        
        // Clear the form fields since we're just adding filters
        document.getElementById('editGroupName').value = group.name;
        document.getElementById('editGroupAction').value = group.action;
        document.getElementById('editGroupPriority').value = group.priority;
        document.getElementById('editGroupActive').checked = group.is_active;
        
        // Load filters for assignment
        await loadFiltersForAssignment(groupId);
        document.getElementById('editGroupModal').classList.add('show');
        
    } catch (error) {
        showNotification(`Error loading group: ${error.message}`, 'error');
    }
}

// Backup functions (global scope for onclick handlers)
async function exportBackup() {
    try {
        const response = await fetch('/admin/backup/export', {
            headers: {
                'X-CSRF-Token': '{{ .CSRFToken }}'
            }
        });
        
        if (response.ok) {
            const blob = await response.blob();
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `infoscope-backup-${new Date().toISOString().split('T')[0]}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            window.URL.revokeObjectURL(url);
            showNotification('Backup exported successfully', 'success');
        } else {
            const error = await response.text();
            showNotification(`Export failed: ${error}`, 'error');
        }
    } catch (error) {
        showNotification(`Export error: ${error.message}`, 'error');
    }
}

async function handleImport() {
    const fileInput = document.getElementById('importFile');
    const file = fileInput.files[0];
    
    if (!file) return;
    
    // Show styled confirmation modal instead of browser confirm
    showImportConfirmation(file, fileInput);
}

function showImportConfirmation(file, fileInput) {
    // Create modal container
    const modal = document.createElement('div');
    modal.className = 'import-confirm-modal';
    modal.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.8);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 10001;
        font-family: 'Courier New', Courier, monospace;
    `;
    
    // Create modal content
    const content = document.createElement('div');
    content.style.cssText = `
        background: #121a2b;
        border: 1px solid #bb6767;
        border-radius: 8px;
        padding: 2rem;
        max-width: 450px;
        color: #e8e8e8;
        text-align: center;
    `;
    
    content.innerHTML = `
        <h3 class="modal-title error-text">â  Confirm Import</h3>
        
        <p class="modal-text">
            This will <strong>replace all current data</strong> including feeds, settings, and filters.<br><br>
            Are you sure you want to continue?
        </p>
        
        <div class="modal-actions center">
            <button id="confirmImportCancel" class="btn btn-secondary">CANCEL</button>
            <button id="confirmImportProceed" class="btn btn-danger">IMPORT</button>
        </div>
    `;
    
    modal.appendChild(content);
    document.body.appendChild(modal);
    
    // Add event handlers
    document.getElementById('confirmImportCancel').onclick = () => {
        document.body.removeChild(modal);
        fileInput.value = ''; // Clear the file input
    };
    
    document.getElementById('confirmImportProceed').onclick = () => {
        document.body.removeChild(modal);
        performImport(file, fileInput);
    };
    
    // Close on background click
    modal.onclick = (e) => {
        if (e.target === modal) {
            document.body.removeChild(modal);
            fileInput.value = '';
        }
    };
}

async function performImport(file, fileInput) {
    try {
        showNotification('Importing backup...', 'info');
        
        const formData = new FormData();
        formData.append('backup', file);
        
        const response = await fetch('/admin/backup/import', {
            method: 'POST',
            headers: {
                'X-CSRF-Token': '{{ .CSRFToken }}'
            },
            body: formData
        });
        
        if (response.ok) {
            const result = await response.json();
            
            // Show import results modal
            showImportResults(result);
            
            // Reload after a delay
            setTimeout(() => location.reload(), 3000);
        } else {
            const error = await response.text();
            showNotification(`Import failed: ${error}`, 'error');
        }
    } catch (error) {
        showNotification(`Import error: ${error.message}`, 'error');
    } finally {
        fileInput.value = '';
    }
}

function showImportResults(result) {
    // Create modal container
    const modal = document.createElement('div');
    modal.className = 'import-results-modal';
    modal.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.8);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 10001;
        font-family: 'Courier New', Courier, monospace;
    `;
    
    // Create modal content
    const content = document.createElement('div');
    content.style.cssText = `
        background: #121a2b;
        border: 1px solid #7da9b7;
        border-radius: 8px;
        padding: 2rem;
        max-width: 500px;
        max-height: 80vh;
        overflow-y: auto;
        color: #e8e8e8;
    `;
    
    const stats = result.stats || {};
    const warnings = result.warnings || [];
    
    content.innerHTML = `
        <h3 class="modal-title success-text">Import Successful!</h3>
        <div class="modal-section">
            <h4 class="modal-subtitle">Import Statistics:</h4>
            <div class="stats-grid">
                <span>Settings:</span><span class="accent">${stats.settings || 0}</span>
                <span>Feeds:</span><span class="accent">${stats.feeds || 0}</span>
                <span>Filters:</span><span class="accent">${stats.filters || 0}</span>
                <span>Filter Groups:</span><span class="accent">${stats.filterGroups || 0}</span>
                <span>Tags:</span><span class="accent">${stats.tags || 0}</span>
                <span>Feed Tags:</span><span class="accent">${stats.feedTags || 0}</span>
                <span>Click Stats:</span><span class="accent">${stats.clickStats || 0}</span>
            </div>
        </div>
        ${warnings.length > 0 ? `
            <div class="modal-section">
                <h4 class="modal-subtitle error-text">Warnings:</h4>
                <div class="warning-box">
                    ${warnings.map(warning => `<div class="warning-item">â  ${warning}</div>`).join('')}
                </div>
            </div>
        ` : ''}
        <div class="modal-actions center">
            <button id="importResultsClose" class="btn btn-secondary">CLOSE</button>
        </div>
        <div class="modal-note">Page will reload automatically in 3 seconds...</div>
    `;
    
    modal.appendChild(content);
    document.body.appendChild(modal);
    
    // Add close event
    document.getElementById('importResultsClose').onclick = () => {
        document.body.removeChild(modal);
        location.reload();
    };
    
    // Close on background click
    modal.onclick = (e) => {
        if (e.target === modal) {
            document.body.removeChild(modal);
            location.reload();
        }
    };
}

// Notification system
function showNotification(message, type) {
    // Create notification element
    const notification = document.createElement('div');
    notification.className = `notification ${type}`;
    notification.innerHTML = `
        <span>${message}</span>
        <button class="notification-close" aria-label="Close notification">&times;</button>
    `;
    
    // Add styles
    notification.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        padding: 1rem 1.5rem;
        border-radius: 4px;
        color: white;
        font-family: 'Courier New', Courier, monospace;
        font-size: 0.9rem;
        z-index: 10000;
        display: flex;
        align-items: center;
        gap: 1rem;
        max-width: 400px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        animation: slideIn 0.3s ease;
    `;
    
    // Type-specific styling
    switch (type) {
        case 'success':
            notification.style.background = '#67bb79';
            notification.style.color = '#121a2b';
            break;
        case 'error':
            notification.style.background = '#ff6b6b';
            break;
        case 'info':
            notification.style.background = '#7da9b7';
            notification.style.color = '#121a2b';
            break;
    }
    
    // Add to page
    document.body.appendChild(notification);
    
    // Auto remove with type-specific duration
    let duration;
    switch (type) {
        case 'success':
            duration = 7000; // 7 seconds for success messages
            break;
        case 'error':
            duration = 9000; // 9 seconds for error messages
            break;
        default:
            duration = 5000; // 5 seconds for other messages
            break;
    }
    
    setTimeout(() => {
        notification.style.animation = 'slideOut 0.3s ease';
        setTimeout(() => notification.remove(), 300);
    }, duration);
}

// Add CSS for notification animations
const style = document.createElement('style');
style.textContent = `
    @keyframes slideIn {
        from { transform: translateX(100%); opacity: 0; }
        to { transform: translateX(0); opacity: 1; }
    }
    @keyframes slideOut {
        from { transform: translateX(0); opacity: 1; }
        to { transform: translateX(100%); opacity: 0; }
    }
    .notification button {
        background: none;
        border: none;
        color: inherit;
        font-size: 1.2rem;
        cursor: pointer;
        padding: 0;
        width: 20px;
        height: 20px;
        display: flex;
        align-items: center;
        justify-content: center;
    }
    
    .modal {
        display: none;
        position: fixed;
        z-index: 1000;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0,0,0,0.8);
        backdrop-filter: blur(3px);
    }
    
    .modal-content {
        background: linear-gradient(135deg, #1a2438 0%, #243248 100%);
        border: 1px solid #2a3450;
        border-radius: 6px;
        box-shadow: 0 8px 32px rgba(0,0,0,0.3);
        margin: 5% auto;
        padding: 0;
        width: 90%;
        max-width: 600px;
        color: #c7d2fe;
        font-family: 'Courier New', Courier, monospace;
    }
    
    .modal-large {
        max-width: 900px;
    }
    
    .modal-header {
        padding: 1.5rem 2rem;
        border-bottom: 1px solid #2a3450;
        display: flex;
        justify-content: space-between;
        align-items: center;
    }
    
    .modal-header h3 {
        margin: 0;
        color: #67bb79;
        font-size: 1.2rem;
        font-weight: bold;
    }
    
    .modal-close {
        background: none;
        border: none;
        color: #c7d2fe;
        font-size: 1.5rem;
        cursor: pointer;
        padding: 0;
        width: 30px;
        height: 30px;
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 3px;
        transition: all 0.2s ease;
    }
    
    .modal-close:hover {
        background: rgba(255,255,255,0.1);
        color: #ff6b6b;
    }
    
    .modal-body {
        padding: 2rem;
    }
    
    .modal-form-group {
        margin-bottom: 1.5rem;
    }
    
    .modal-form-group label {
        display: block;
        margin-bottom: 0.5rem;
        color: #67bb79;
        font-weight: bold;
        font-size: 0.9rem;
    }
    
    .modal-form-group input,
    .modal-form-group select {
        width: 100%;
        padding: 0.7rem;
        border: 1px solid #2a3450;
        border-radius: 4px;
        background: #121a2b;
        color: #c7d2fe;
        font-family: 'Courier New', Courier, monospace;
        font-size: 0.9rem;
    }
    
    .modal-form-group input:focus,
    .modal-form-group select:focus {
        outline: none;
        border-color: #67bb79;
        box-shadow: 0 0 0 2px rgba(103, 187, 121, 0.2);
    }
    
    .form-help {
        font-size: 0.8rem;
        color: #7da9b7;
        margin-top: 0.3rem;
        font-style: italic;
    }
    
    .checkbox-label {
        display: flex !important;
        align-items: center;
        gap: 0.5rem;
        cursor: pointer;
    }
    
    .checkbox-label input[type="checkbox"] {
        width: auto;
        margin: 0;
    }
    
    .modal-footer {
        padding: 1.5rem 2rem;
        border-top: 1px solid #2a3450;
        display: flex;
        justify-content: flex-end;
        gap: 1rem;
    }
    
    .filter-assignment {
        margin-top: 2rem;
        padding-top: 2rem;
        border-top: 1px solid #2a3450;
    }
    
    .filter-assignment h4 {
        color: #67bb79;
        margin-bottom: 1rem;
        font-size: 1rem;
    }
    
    .assigned-filters,
    .available-filters {
        max-height: 200px;
        overflow-y: auto;
        border: 1px solid #2a3450;
        border-radius: 4px;
        background: #121a2b;
        margin-bottom: 1.5rem;
    }
    
    .filter-assignment-item {
        display: flex;
        align-items: center;
        padding: 0.8rem;
        border-bottom: 1px solid #1a2438;
        gap: 0.5rem;
    }
    
    .filter-assignment-item:last-child {
        border-bottom: none;
    }
    
    .assignment-info {
        flex: 1;
    }
    
    .assignment-name {
        font-weight: bold;
        color: #c7d2fe;
        margin-bottom: 0.2rem;
    }
    
    .assignment-pattern {
        font-size: 0.8rem;
        color: #7da9b7;
        font-family: monospace;
    }
    
    .assignment-actions {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        margin-left: auto;
    }
    
    .assignment-operator {
        padding: 0.5rem 0.7rem;
        border: 1px solid #2a3450;
        border-radius: 4px;
        background: #121a2b;
        color: #c7d2fe;
        font-family: 'Courier New', Courier, monospace;
        font-size: 0.8rem;
        width: auto;
        min-width: 80px;
        transition: all 0.2s ease;
    }
    
    .assignment-operator:focus {
        outline: none;
        border-color: #4f46e5;
        box-shadow: 0 0 0 2px rgba(79, 70, 229, 0.2);
    }
    
    .assignment-btn {
        padding: 0.4rem 0.8rem;
        font-size: 0.8rem;
        border: 1px solid #2a3450;
        border-radius: 3px;
        background: #1a2438;
        color: #c7d2fe;
        cursor: pointer;
        transition: all 0.2s ease;
    }
    
    .assignment-btn:hover {
        background: #2a3450;
        border-color: #67bb79;
    }
    
    .assignment-btn.primary {
        background: #67bb79;
        color: #121a2b;
        border-color: #67bb79;
    }
    
    .assignment-btn.primary:hover {
        background: #7cc98a;
        border-color: #7cc98a;
    }
    
    .logic-operator-section {
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 0.5rem;
        margin-right: 1rem;
        background: rgba(103, 187, 121, 0.1);
        border-radius: 4px;
        border: 1px solid rgba(103, 187, 121, 0.3);
    }
    
    .logic-operator-section .assignment-operator {
        background: transparent;
        border: none;
        color: #67bb79;
        font-weight: 600;
        padding: 0.2rem 0.4rem;
        font-size: 0.8rem;
    }
    
    .logic-operator-section .assignment-operator:focus {
        box-shadow: none;
        outline: 1px solid #67bb79;
    }
    
    .empty-state.small {
        padding: 2rem;
        text-align: center;
        color: #7da9b7;
        font-style: italic;
    }
`;
document.head.appendChild(style);

// Drag and Drop handlers for filter reordering
let draggedFilterItem = null;

function handleFilterDragStart(e) {
    draggedFilterItem = e.target;
    e.target.classList.add('dragging');
    e.target.style.opacity = '0.5';
    e.dataTransfer.effectAllowed = 'move';
    e.dataTransfer.setData('text/plain', e.target.dataset.filterId);
    
    console.log('Drag started for filter:', e.target.dataset.filterId);
}

function handleFilterDragEnd(e) {
    e.target.style.opacity = '1';
    e.target.classList.remove('dragging');
    draggedFilterItem = null;
    
    // Remove drag-over classes from all items
    document.querySelectorAll('.filter-assignment-item').forEach(item => {
        item.classList.remove('drag-over');
    });
    
    console.log('Drag ended');
}

function setupAssignedFiltersDragAndDrop() {
    const assignedContainer = document.getElementById('assignedFilters');
    if (!assignedContainer) return;
    
    assignedContainer.addEventListener('dragover', handleAssignedDragOver);
    assignedContainer.addEventListener('drop', handleAssignedDrop);
}

function handleAssignedDragOver(e) {
    e.preventDefault();
    e.dataTransfer.dropEffect = 'move';
    
    const container = e.currentTarget;
    const afterElement = getDragAfterElement(container, e.clientY);
    const draggingItem = container.querySelector('.dragging');
    
    if (draggingItem && afterElement !== draggingItem) {
        if (afterElement == null) {
            container.appendChild(draggingItem);
        } else {
            container.insertBefore(draggingItem, afterElement);
        }
    }
}

function handleAssignedDrop(e) {
    e.preventDefault();
    console.log('Drop event triggered');
    
    // The reordering already happened during dragover
    // Now we just need to update the operators
    setTimeout(() => {
        reorderAssignedFilters();
    }, 10);
}

function getDragAfterElement(container, y) {
    const draggableElements = [...container.querySelectorAll('.draggable:not(.dragging)')];
    
    return draggableElements.reduce((closest, child) => {
        const box = child.getBoundingClientRect();
        const offset = y - box.top - box.height / 2;
        
        if (offset < 0 && offset > closest.offset) {
            return { offset: offset, element: child };
        } else {
            return closest;
        }
    }, { offset: Number.NEGATIVE_INFINITY }).element;
}

function reorderAssignedFilters() {
    const assignedContainer = document.getElementById('assignedFilters');
    const items = [...assignedContainer.querySelectorAll('.filter-assignment-item')];
    
    console.log('Reordering', items.length, 'filters');
    
    // Update operators: first item should not have an operator, others should have AND/OR
    items.forEach((item, index) => {
        const existingOperatorSection = item.querySelector('.logic-operator-section');
        const dragHandle = item.querySelector('.drag-handle');
        
        if (index === 0) {
            // First item (top-level filter) should not have an operator
            if (existingOperatorSection) {
                existingOperatorSection.remove();
                console.log('Removed operator from first filter');
            }
        } else {
            // Subsequent items need boolean operators (AND/OR)
            if (!existingOperatorSection) {
                const filterId = item.dataset.filterId;
                const operatorHTML = `
                    <div class="logic-operator-section">
                        <select class="assignment-operator" data-filter-id="${filterId}">
                            <option value="AND" selected>AND</option>
                            <option value="OR">OR</option>
                        </select>
                    </div>
                `;
                
                // Insert after drag handle if it exists, otherwise at the beginning
                if (dragHandle) {
                    dragHandle.insertAdjacentHTML('afterend', operatorHTML);
                } else {
                    item.insertAdjacentHTML('afterbegin', operatorHTML);
                }
                console.log('Added operator to filter', index);
            }
        }
    });
    
    console.log('Filters reordered successfully. Order:');
    items.forEach((item, i) => {
        const name = item.querySelector('.assignment-name')?.textContent;
        const hasOperator = !!item.querySelector('.logic-operator-section');
        console.log(`${i + 1}. ${name} (has operator: ${hasOperator})`);
    });
}

// Expose functions to global scope for onclick handlers
window.editFilter = editFilter;
window.deleteFilter = deleteFilter;
window.showCreateFilterModal = showCreateFilterModal;

// Initialize theme selection checkboxes based on saved settings
document.addEventListener('DOMContentLoaded', function() {
    // Set the correct theme checkboxes based on saved settings
    const savedThemes = '{{ index .Data.Settings "public_available_themes" }}';
    if (savedThemes && savedThemes.trim() !== '') {
        // Uncheck all theme checkboxes first
        document.querySelectorAll('input[name="public_available_themes"]').forEach(cb => {
            cb.checked = false;
        });
        
        // Check only the saved themes
        const themesArray = savedThemes.split(',');
        themesArray.forEach(theme => {
            const checkbox = document.querySelector(`input[name="public_available_themes"][value="${theme.trim()}"]`);
            if (checkbox) {
                checkbox.checked = true;
            }
        });
    }
});
</script>

<!-- Create Filter Group Modal removed -->

<!-- Create Filter Modal removed -->

<!-- Edit Filter Modal removed -->

<!-- Edit Group Modal removed -->

<!-- Delete Filter Modal removed -->

<!-- Delete Group Modal removed -->

{{ end }}
